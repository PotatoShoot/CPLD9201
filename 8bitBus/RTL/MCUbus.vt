`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    2024/04/27
// Design Name:     FPGA-MCU 8-bit Bus Communication
// Module Name:     bus_comm
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////

module MCUbus (
    input wire clk,             // 系统时钟
    input wire rst_n,           // 复位信号，低有效
    inout wire [7:0] DB,  // 八位双向数据总线
    input wire ALE,             // 地址锁存使能，低有效
    input wire WR,              // 写使能，低有效
    input wire RD               // 读使能，低有效
);

// 定义内部寄存器
reg [7:0] address_latch; // 地址锁存寄存器
reg [7:0] data_regs [4:0]; // 五个8位数据寄存器 (0x50 - 0x54)
reg [7:0] data_out; // 用于驱动 DB 的数据
reg DB_tristate; // 控制 DB 是否驱动

// 定义地址范围
localparam ADDR_START = 8'h50;
localparam ADDR_END   = 8'h54;

// 初始化寄存器
integer i;
initial begin
    for (i = 0; i < 5; i = i + 1) begin
        data_regs[i] = 8'h00;
    end
    address_latch = 8'h00;
    data_out = 8'h00;
    DB_tristate = 1'b0;
end

// 地址锁存逻辑
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        address_latch <= 8'h00;
    end else begin
        if (!ALE) begin
            address_latch <= DB;
        end
    end
end

// 写入数据逻辑
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // 重置寄存器
        for (i = 0; i < 5; i = i + 1) begin
            data_regs[i] <= 8'h00;
        end
    end else begin
        if (!WR && ALE) begin // 确保 ALE 已完成地址锁存
            // 检查地址是否在范围内
            if (address_latch >= ADDR_START && address_latch <= ADDR_END) begin
                data_regs[address_latch - ADDR_START] <= DB;
            end
            // 可选择处理地址越界的情况
        end
    end
end

// 读取数据逻辑
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        data_out <= 8'hZZ;
        DB_tristate <= 1'b0;
    end else begin
        if (!RD && ALE) begin // 确保 ALE 已完成地址锁存
            // 检查地址是否在范围内
            if (address_latch >= ADDR_START && address_latch <= ADDR_END) begin
                DB_tristate <= 1'b1; // 启动驱动
                data_out <= data_regs[address_latch - ADDR_START];
            end else begin
                data_out <= 8'hZZ; // 高阻
                DB_tristate <= 1'b0;
            end
            // 可选择处理地址越界的情况
        end else begin
            data_out <= 8'hZZ; // 非读取操作时高阻
            DB_tristate <= 1'b0;
        end
    end
end

// 三态缓冲区驱动
assign DB = (DB_tristate) ? data_out : 8'hZZ;

endmodule
